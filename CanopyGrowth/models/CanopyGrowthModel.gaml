// Goal of this model is to get rid of canopy rate estimation by grid,
// and instead add up the exact value of the area of each tree (area of a circle)
// with the caveat of double counting each overlapping part of the canopies.
model TreeGrowth

// By default the world has 100m x 100m dimensions.
global {

//  #################################
//  ***** VARIABLES DECLARATION *****
//  #################################
	int current_year <- 2021;
	// Amount of new trees to be planted
	float tree_spawn_rate;
	// Probability to have a new tree planted at the same location after a tree has been cut.
	float plant_new_tree;
	// Location selected by the user with a LMB click.
	point selected_location;
	// Number of trees, can be modified by the user.
	int n_treesA;
	int n_treesB;
	int n_treesC;
	// Maximum canopy_diameter of the trees.
	float max_canopy_diameterA; //meters
	float max_canopy_diameterB; //meters
	float max_canopy_diameterC; //meters
	// Maximum canopy_height of the trees.
	float max_canopy_heightA; //meters
	float max_canopy_heightB; //meters
	float max_canopy_heightC; //meters
	// Maximum lifetime of the trees.
	float max_lifetimeA; //years
	float max_lifetimeB; //years
	float max_lifetimeC; //years
	// Percentage of maximum canopy size reached by the trees at half life.
	float rA;
	float rB;
	float rC;
	// Growth stress multiplier for each tree
	float GSM_A;
	float GSM_B;
	float GSM_C;
	// Age at Plantation Date for each tree
	int APD_A;
	int APD_B;
	int APD_C;

	// Premature death for trees at this age
	bool premature_death_bool;
	int premature_death_age;

	// Change this root when switching regions of interest.
	//string path_root <- "../includes/Plainpalais/";
	string path_root <- "../includes/Plainpalais2/";
	//string path_root <- "../includes/Bastions/";
	//string path_root <- "../includes/ParcDesRois/";

	// The user may or may not allow the trees to die once they exceed their max lifetime.
	bool treesCanDie;
	float world_area <- 100000.0;

	// Real-time computation of the canopy proportion : sum of all trees' canopy area, divided by world area.
	int total_canopy_area <- 0.0 update: sum_of(agents of_generic_species Trees, each.canopy_area);
	float canopy_percentage <- 0.0 update: (100.0 * total_canopy_area / world_area) with_precision 2;

	// Declare all variables linked to temperature computation.
	float average_temperature <- 0.0 update: temperature_grid mean_of (each.temperature) with_precision 2;
	float temperature_exposed;
	float temperature_decrease_per_tree;
	// sigma [0,1] is the multiplier involved when calculating the effect of the distance to the trunk of the tree on the cell's temperature.
	// A cell closer to the trunk will have a lower temperature than a cell at the edge of the canopy.
	float sigma;

	// Load shapefile of trees geolocalization.
	file arbres_isoles_shapefile <- shape_file(path_root + "ICA_Cropped_Data.shp");
	// Lidar files for validation.
	//file lidar2017 <- shape_file(path_root + "LIDAR2017_Data.shp");
	//file lidar2019 <- shape_file(path_root + "LIDAR2019_Data.shp");
	// Load file of basemap.
	file basemap <- image_file(path_root + "basemap_Cropped.png");

	// Load key parameters from the file generated by the user during the validation.
	matrix key_parameters <- matrix(csv_file(path_root + "allCalibrationParameters.csv"));

	// Initialize the string that will contain the saved canopy rate values.
	string canopy_rate_history <- "Year;Canopy Rate\n";

	// Re-define the world to fit the envelope of the shapefiles.
	geometry shape <- envelope(arbres_isoles_shapefile);

	// ################################
	// ***** MODEL INITIALIZATION *****
	// ################################

	// When creating the world, create generic trees based on their localization and plantation date in the shapefile to determine their age,
	// also get their category to determine which species to plant.
	init {

	// Plainpalais World area, as calculated by B. Guinaudeau.
	// Bastions World area, as measured on ArcGis.
	// Parc Des Rois World area, as measured on ArcGis.
		if path_root = "../includes/Plainpalais/" {
			world_area <- 112514.0;
		} else if path_root = "../includes/Plainpalais2/" {
			world_area <- 112514.0;
		} else if path_root = "../includes/Bastions/" {
			world_area <- 88145.8;
		} else if path_root = "../includes/ParcDesRois/" {
			world_area <- 28730.0;
		}

		create Trees from: arbres_isoles_shapefile with:
		[plantation_date::string(get("DATE_PLANT")), category::string(get("Categorie")), canopyD_fromSource::float(get("DIAMETRE_C")), totalH_fromSource::float(get("HAUTEUR_TO")), trunkH_fromSource::float(get("HAUTEUR_TR"))];
		// Ask the trees to fetch their time_in_soil amount, based on their plantation date.
		ask Trees {
		// Get plantation year.
			if plantation_date != nil {
				plantation_year <- int(copy_between(plantation_date, length(plantation_date) - 4, length(plantation_date)));
			}
			// If plantation date exists and is posterior to 1980
			if plantation_date != nil and plantation_year >= 1980 {
			// Calculate time in soil
				time_in_soil <- current_year - plantation_year;
				// The tree can be modelled.
				canBeModelled <- true;
			}
			//Otherwise, canBeModelled stays false, the tree will have a fixed age and size.

			// Each generic tree will then create a tree of the adequate category, based on the data in the attribute table.
			// Don't forget to keep the location, time in soil, GSM quantities and "canBeModelled?" property.
			if category = "Petit" {
				create TreesA number: 1 with:
				(location: location, time_in_soil: time_in_soil, growth_stress_multiplier: growth_stress_multiplier, canBeModelled: canBeModelled, canopyD_fromSource: canopyD_fromSource, totalH_fromSource: totalH_fromSource, trunkH_fromSource: trunkH_fromSource);
			} else if category = "Moyen" {
				create TreesB number: 1 with:
				(location: location, time_in_soil: time_in_soil, growth_stress_multiplier: growth_stress_multiplier, canBeModelled: canBeModelled, canopyD_fromSource: canopyD_fromSource, totalH_fromSource: totalH_fromSource, trunkH_fromSource: trunkH_fromSource);
			} else if category = "Grand" {
				create TreesC number: 1 with:
				(location: location, time_in_soil: time_in_soil, growth_stress_multiplier: growth_stress_multiplier, canBeModelled: canBeModelled, canopyD_fromSource: canopyD_fromSource, totalH_fromSource: totalH_fromSource, trunkH_fromSource: trunkH_fromSource);
			} else {
			// If no category is detected, create a medium tree [calibration data for small trees is not yet available].
				create TreesB number: 1 with:
				(location: location, time_in_soil: time_in_soil, growth_stress_multiplier: growth_stress_multiplier, canBeModelled: canBeModelled, canopyD_fromSource: canopyD_fromSource, totalH_fromSource: totalH_fromSource, trunkH_fromSource: trunkH_fromSource);
			}

			// Generic trees were only useful to create the species-specific trees based on the Category attribute; they are no longer needed.
			do die;
		}

		// Important note : when the species-specific trees are created, they automatically get affected a value for their key parameters,
		// such as max_canopy, max_lifetime, etc.
		ask agents of_generic_species Trees {
		// If the tree is marked for modeling, then its values will change dynamically, so it is only necessary to set the initial values.
			if canBeModelled {
			// Initialize the age of the trees based on their age in the shapefile.
			// It cannot exceed the maximum lifetime set for that species.
				age <- int(min(time_in_soil + age_at_plantation_date, t_max));

				// Initialize the canopy size of the trees based on their age in the shapefile. Visualisation purposes only.
				if t_max != 0 {
					cubic_weighting_D <- (8 * r * y_max_D - 6 * y_max_D) / t_max ^ 3;
					quadratic_weighting_D <- (-16 * r * y_max_D + 11 * y_max_D) / t_max ^ 2;
					linear_weighting_D <- (8 * r * y_max_D - 4 * y_max_D) / t_max;
					canopy_diameter <- max(canopyD_fromSource, growth_stress_multiplier * (cubic_weighting_D * age ^ 3 + quadratic_weighting_D * age ^ 2 + linear_weighting_D * age));
				}

			} else {
			// If it can't be modelled, then it is important to set all necessary values now, since they won't be recomputed. 
				canopy_diameter <- canopyD_fromSource;
				canopy_height <- totalH_fromSource - trunkH_fromSource;
				canopy_area <- #pi * (canopy_diameter / 2) ^ 2;
				canopy_volume <- 2 / 3 * canopy_area * canopy_height;
			}

		}

		// For Trees that have absolutely no data available
		// We set their canopy to the maximum between an arbitrarily low canopy diameter (2m), and the mean of its neighboring (within 50m range) trees' canopy diameter.
		// Same thing for canopy height. We can then compute canopy area and canopy volume.
		// These values won't be recomputed as well.
		ask agents of_generic_species Trees {
			if not canBeModelled and canopyD_fromSource = 0 {
				canopy_diameter <- max(2, mean_of(agents of_generic_species Trees at_distance 50, each.canopy_diameter));
				canopy_height <- max(3, mean_of(agents of_generic_species Trees at_distance 50, each.totalH_fromSource - each.trunkH_fromSource));
				canopy_area <- #pi * (canopy_diameter / 2) ^ 2;
				canopy_volume <- 2 / 3 * canopy_area * canopy_height;
			}

		} }

		//
	// ######################################
	// ***** MODEL ACTIONS AND BEHAVIOR *****
	// ######################################

	// Action called by a LMB click from the user, it saves the location where the click happened.
	// Used to mark the location by a red cross and invoked by the following action.
	action get_location {
		selected_location <- #user_location;
	}

	// User may ask to plant one or more trees whenever they wish to do so.
	// General process is : create specified number of trees, if need be specify the location, mark them as ready for modelling
	// Set their age to be ADP minus 1, because we then compute the modelled values once (thus increasing age by 1 in the process).

	// Invoked by the user, plants a tree at the location marked by a red cross.
	action plant_tree_at_locationA {
		create TreesA number: 1 with: (location: selected_location, canBeModelled: true, age: APD_A - 1) returns: children;
		ask children {
			do computeAllModelledValues;
		} }

		// Invoked by the user, plants a defined number of trees at random locations.
	action plant_trees_randomlyA {
		create TreesA number: n_treesA with: (canBeModelled: true, age: APD_A - 1) returns: children;
		ask children {
			do computeAllModelledValues;
		} }

		// Invoked by the user, plants a tree at the location marked by a red cross.
	action plant_tree_at_locationB {
		create TreesB number: 1 with: (location: selected_location, canBeModelled: true, age: APD_B - 1) returns: children;
		ask children {
			do computeAllModelledValues;
			self.canopy_color <- #red;
		} }

		// Invoked by the user, plants a defined number of trees at random locations.
	action plant_trees_randomlyB {
		create TreesB number: n_treesB with: (canBeModelled: true, age: APD_B - 1) returns: children;
		ask children {
			do computeAllModelledValues;
		} }
		// Invoked by the user, plants a tree at the location marked by a red cross.
	action plant_tree_at_locationC {
		create TreesC number: 1 with: (location: selected_location, canBeModelled: true, age: APD_C - 1) returns: children;
		ask children {
			do computeAllModelledValues;
		} }

		// Invoked by the user, plants a defined number of trees at random locations.
	action plant_trees_randomlyC {
		create TreesC number: n_treesC with: (canBeModelled: true, age: APD_C - 1) returns: children;
		ask children {
			do computeAllModelledValues;
		} }

		// Refresh all key input values.
	action update_values {
		ask TreesA {
			do get_input_valuesA;
		}

		ask TreesB {
			do get_input_valuesB;
		}

		ask TreesC {
			do get_input_valuesC;
		}

		// Does this part need to go ?
		ask agents of_generic_species Trees {
			if t_max != 0 {
				cubic_weighting_D <- (8 * r * y_max_D - 6 * y_max_D) / t_max ^ 3;
				quadratic_weighting_D <- (-16 * r * y_max_D + 11 * y_max_D) / t_max ^ 2;
				linear_weighting_D <- (8 * r * y_max_D - 4 * y_max_D) / t_max;
				canopy_diameter <- growth_stress_multiplier * (cubic_weighting_D * age ^ 3 + quadratic_weighting_D * age ^ 2 + linear_weighting_D * age);
			}

		}

	}

	// Spawn trees randomly, according to the tree spawn rate defined above.
	reflex spawn_trees when: flip(tree_spawn_rate) {
		create one_of([TreesB, TreesC]) number: 1;
	}

	// Asks all cells under canopy to update their canopy status to true, false otherwise.
	reflex update_canopy_proportion {
		ask temperature_grid {
			under_canopy <- 0;
			temperature <- temperature_exposed;
		}

		// "agents of_generic_species Trees lets me get all agents in species Trees and its subspecies. By default, calling "Trees" does NOT also call its subspecies.
		ask agents of_generic_species Trees {
		// Ask all cells within a given distance from the tree
			ask temperature_grid at_distance (1.5 * canopy_diameter / 2) {
			// Mark that these cells are under the canopy of that tree.
				self.under_canopy <- self.under_canopy + 1;
				// Each tree will have an impact on the local temperature, based on the temperature decrese per tree,the impacted cell's distance to the trunk of the tree, and sigma.
				// However, it cannot influence the temperature to drop below 7.0 degrees under the max temperature.
				temperature <- max(temperature_exposed - 7.0, temperature - temperature_decrease_per_tree * (1 - sigma * (topology(world) distance_between
				[self, myself]) / (myself.canopy_diameter)));
			}

		}

	}

	// Save canopy rate to a CSV file in the includes folder.
	reflex save_canopy_rate {
		canopy_rate_history <- canopy_rate_history + string(cycle + current_year - 1) + ";" + string(canopy_percentage) + "\n";
		save [canopy_rate_history] to: (path_root + "saved_canopy_rates.csv") type: csv;
	} }

	//
// #######################################
// ***** DEFINE GENERIC TREE SPECIES *****
// #######################################
species Trees {
// Tree Category : Small, Medium, or Large.
	string category;
	// Plantation date and year
	string plantation_date;
	int plantation_year;
	// Can the tree be modelled, based on existing data and plantation year ?
	bool canBeModelled <- false;
	// Age, in number of cycles. One cycle = one year.
	int age;
	int time_in_soil;
	// Age at Plantation Date, or APD for short.
	int age_at_plantation_date;
	// y_max_D is short for max canopy diameter.
	float y_max_D;
	// y_max_H is short for max canopy height.
	float y_max_H;
	// t_max is short for max lifetime.
	float t_max;
	// r is the percentage of max canopy size reached by the canopy at half life.
	float r;

	// Get canopy diameter from source attribute table
	float canopyD_fromSource;
	// Get canopy height from source attribute table
	float totalH_fromSource;
	float trunkH_fromSource;
	float canopyH_fromSource;

	// Growth stress multiplier due to tree situation. Shared among all trees.
	float growth_stress_multiplier;
	// Equation of canopy size in function of age : Canopy = A * age^3 + B * age^2 + C*age.
	// Let y be the maximum canopy size of the tree and x be the max lifetime of the tree (where canopy size is maximum).
	// Hence Ax^3 + Bx^2 + Cx = y. As it's also the maximum, 3Ax^2 + 2Bx + C = 0.
	// Also, at mid-growth, we have A(x/2)^3 + B(x/2)^2 + C(x/2) = ry.
	// Solving these three equations for A, B and C gives us the formulas written in the action "computeAllModelledValues".
	float cubic_weighting_D <- 0.0;
	float quadratic_weighting_D <- 0.0;
	float linear_weighting_D <- 0.0;
	float canopy_diameter <- 0.0;
	float canopy_area <- 0.0;
	// Now the same for canopy height
	float cubic_weighting_H <- 0.0;
	float quadratic_weighting_H <- 0.0;
	float linear_weighting_H <- 0.0;
	float canopy_height <- 0.0;
	// Canopy volume is estimated using the formula for a half-ellipsoid of height h and base area canopy_area (which is a circle of radius d/2)
	float canopy_volume <- 0.0;
	rgb canopy_color;

	// We shift the modelling of the trees to this reflex, instead of simple updates.
	// This will let us control which trees have their quantities changed dynamically,
	// and which trees need to have their quantities fixed.
	reflex tree_modelling when: canBeModelled {
		do computeAllModelledValues;
	}

	// We separate the reflex from the actions, so that we can call the action at any time.
	action computeAllModelledValues {
	// If user wants the trees to die, then their age is incremented at every step and their age may exceed their max lifetime, causing them to die.
	// If user does not want the trees to die, their age is incremented only if their age is strictly inferior to their max lifetime.
	// As a result, they will never exceed their max lifetime, they will never die, and their canopy will not evolve anymore.
		if age < t_max or treesCanDie {
			age <- age + 1;
		}

		//
		cubic_weighting_D <- (8 * r * y_max_D - 6 * y_max_D) / t_max ^ 3;
		quadratic_weighting_D <- (-16 * r * y_max_D + 11 * y_max_D) / t_max ^ 2;
		linear_weighting_D <- (8 * r * y_max_D - 4 * y_max_D) / t_max;
		// sometimes the calculated canopy diameter is way lower than the actual recorded canopy diameter : how to solve this problem ?
		// Current solution is to just take the higher value between the computed value and the recorded value.
		canopy_diameter <- max(canopyD_fromSource, growth_stress_multiplier * (cubic_weighting_D * age ^ 3 + quadratic_weighting_D * age ^ 2 + linear_weighting_D * age));
		canopy_area <- #pi * (canopy_diameter / 2) ^ 2;
		//
		cubic_weighting_H <- (8 * r * y_max_H - 6 * y_max_H) / t_max ^ 3;
		quadratic_weighting_H <- (-16 * r * y_max_H + 11 * y_max_H) / t_max ^ 2;
		linear_weighting_H <- (8 * r * y_max_H - 4 * y_max_H) / t_max;
		canopy_height <- max(canopyH_fromSource, growth_stress_multiplier * (cubic_weighting_H * age ^ 3 + quadratic_weighting_H * age ^ 2 + linear_weighting_H * age));
		//
		canopy_volume <- 2 / 3 * canopy_area * canopy_height;
	}

	// Each step, the tree is cut if it exceeds its maximum lifetime, and if the user allows the trees to die.
	// If it does, it has a probability of being replaced by a new tree of a random species. This new tree is planted at the same location as the old tree, and is 10 years old.
	// The new tree also inherits the ability to be modelled.
	// Finally, the initial tree dies.
	reflex cut_tree {
		if age > t_max or (premature_death_bool and age > premature_death_age) {
			if flip(plant_new_tree) {
				create one_of([TreesB, TreesC]) number: 1 with: (age: 10, location: location, growth_stress_multiplier: growth_stress_multiplier, canBeModelled: canBeModelled);
			}

			do die;
		} }

		// Its aspect is a brown circle surrounded by a black outline representing its canopy. Color varies depending on the type of tree.
	aspect base {
		draw circle(canopy_diameter / 2) color: canopy_color border: #black;
		draw circle(0.1) color: #brown border: #black;
		//draw string("Age : " + age + ", canopy : " + canopy with_precision 2) color: #black font: font("Helvetica", 24, #bold);
	} }

	//
// ########################################
// ***** DEFINE SPECIFIC TREE SPECIES *****
// ########################################

// Declare each species of tree used as a subspecies of the mother species "Trees". They have their own values of max canopy size, max lifetime and color.
// They also have a separate action to get input values from the user.
species TreesA parent: Trees {

	init {
		do get_input_valuesA;
		canopy_color <- rgb(180, 200, 180);
	}

	action get_input_valuesA {
		y_max_D <- max_canopy_diameterA;
		y_max_H <- max_canopy_heightA;
		t_max <- max_lifetimeA;
		r <- rA;
		age_at_plantation_date <- APD_A;
		growth_stress_multiplier <- GSM_A;
	}

}

species TreesB parent: Trees {

	init {
		do get_input_valuesB;
		canopy_color <- rgb(0, 180, 0);
	}

	action get_input_valuesB {
		y_max_D <- max_canopy_diameterB;
		y_max_H <- max_canopy_heightB;
		t_max <- max_lifetimeB;
		r <- rB;
		age_at_plantation_date <- APD_B;
		growth_stress_multiplier <- GSM_B;
	}

}

species TreesC parent: Trees {

	init {
		do get_input_valuesC;
		canopy_color <- rgb(0, 80, 0);
	}

	action get_input_valuesC {
		y_max_D <- max_canopy_diameterC;
		y_max_H <- max_canopy_heightC;
		t_max <- max_lifetimeC;
		r <- rC;
		age_at_plantation_date <- APD_C;
		growth_stress_multiplier <- GSM_C;
	}

}

// ###################################
// ***** DEFINE TEMPERATURE GRID *****
// ###################################
grid temperature_grid width: 100 height: 300 {
	int under_canopy <- 0;
	// DeltaT = DeltaT_max * (1 - sigma * distance to trunk / radius of the canopy of the tree)
	float temperature <- temperature_exposed;
	// Color codes used for the heatmap : green when at Tmax - 7 (the minimum temperature), red when at Tmax.
	// Color starts at red at highest temperatures, transitions to yellow when going down until halfway.
	// During this stage, red stays at 255, while green goes up to reach 255. 
	// Second phase : green staysat 255, while red goes down to 50 when the minimum temperature is reached.
	int color_value <- 0 update: max(50, int(-255 * (temperature - temperature_exposed) / 3.5));
	rgb color <- rgb(255 - max(50, color_value - 255), min(255, color_value), 50) update: rgb(255 - max(50, color_value - 255), min(255, color_value), 50);

	aspect base {
		draw shape color: color;
	}

}

// ##################################
// ***** DEFINE MAIN EXPERIMENT *****
// ##################################
experiment MainExperiment type: gui {

// Define parameters that can be set by the user. This will let the user choose the amount of trees to be spawned at random locations, the max canopy_diameter of the trees,
// the max lifetime of the trees (per species), as well as the temperature under direct sunlight and the temperature when protected by the canopy. And other stuff.
	parameter "Max canopy diameter of Small Trees" var: max_canopy_diameterA <- float(key_parameters[3, 0]) category: "Small Trees";
	parameter "Max canopy height of Small Trees" var: max_canopy_heightA <- float(key_parameters[4, 0]) category: "Small Trees";
	parameter "Max lifetime of Small Trees" var: max_lifetimeA <- float(key_parameters[5, 0]) category: "Small Trees";
	parameter "Proportion of maximum canopy size reached by Small Trees at half life [0,1]" var: rA <- float(key_parameters[6, 0]) category: "Small Trees";
	parameter "Age at plantation date for Small Trees" var: APD_A <- int(key_parameters[7, 0]) category: "Small Trees";
	parameter "Growth stress multiplier for Small Trees" var: GSM_A <- float(key_parameters[8, 0]) category: "Small Trees";
	parameter "Number of Small Trees to plant" var: n_treesA <- 5 category: "Small Trees";
	//
	parameter "Max canopy diameter of Medium Trees" var: max_canopy_diameterB <- float(key_parameters[3, 1]) category: "Medium Trees";
	parameter "Max canopy height of Medium Trees" var: max_canopy_heightB <- float(key_parameters[4, 1]) category: "Medium Trees";
	parameter "Max lifetime of Medium Trees" var: max_lifetimeB <- float(key_parameters[5, 1]) category: "Medium Trees";
	parameter "Proportion of maximum canopy size reached by Medium Trees at half life [0,1]" var: rB <- float(key_parameters[6, 1]) category: "Medium Trees";
	parameter "Age at plantation date for Medium Trees" var: APD_B <- int(key_parameters[7, 1]) category: "Medium Trees";
	parameter "Growth stress multiplier for Medium Trees" var: GSM_B <- float(key_parameters[8, 1]) category: "Medium Trees";
	parameter "Number of Medium Trees to plant" var: n_treesB <- 5 category: "Medium Trees";
	//
	parameter "Max canopy diameter of Large Trees" var: max_canopy_diameterC <- float(key_parameters[3, 2]) category: "Large Trees";
	parameter "Max canopy height of Large Trees" var: max_canopy_heightC <- float(key_parameters[4, 2]) category: "Large Trees";
	parameter "Max lifetime of Large Trees" var: max_lifetimeC <- float(key_parameters[5, 2]) category: "Large Trees";
	parameter "Proportion of maximum canopy size reached by Large Trees at half life [0,1]" var: rC <- float(key_parameters[6, 2]) category: "Large Trees";
	parameter "Age at plantation date for Large Trees" var: APD_C <- int(key_parameters[7, 2]) category: "Large Trees";
	parameter "Growth stress multiplier for Large Trees" var: GSM_C <- float(key_parameters[8, 2]) category: "Large Trees";
	parameter "Number of Large Trees to plant" var: n_treesC <- 5 category: "Large Trees";
	//
	parameter "Temperature under direct sunlight" var: temperature_exposed <- 0.0;
	parameter "Temperature decrease per tree" var: temperature_decrease_per_tree <- 2.5;
	parameter "New tree spawning rate [0,1]" var: tree_spawn_rate <- 0.0;
	parameter "Probability of planting a new tree after an existing one has been cut [0,1]" var: plant_new_tree <- 1.0;
	parameter "Effect of the distance to the trunk of the tree on the cooling effect of its canopy [0,1]" var: sigma <- 0.0;
	parameter "Can the trees die ?" var: treesCanDie <- true;
	parameter "Can the trees die prematurely ?" var: premature_death_bool <- false;
	parameter "At what age do the trees die prematurely ?" var: premature_death_age <- 50;

	// On a press of this button, the above number of trees will be planted at random locations.
	user_command "Plant N Small Trees at random locations" action: plant_trees_randomlyA category: "Small Trees";
	// On a press of this button, a tree will be planted at the current red cross' location.
	user_command "Plant a Small Tree at selected location" action: plant_tree_at_locationA category: "Small Trees";
	// On a press of this button, the above number of trees will be planted at random locations.
	user_command "Plant N Medium Trees at random locations" action: plant_trees_randomlyB category: "Medium Trees";
	// On a press of this button, a tree will be planted at the current red cross' location.
	user_command "Plant a Medium Tree at selected location" action: plant_tree_at_locationB category: "Medium Trees";
	// On a press of this button, the above number of trees will be planted at random locations.
	user_command "Plant N Large Trees at random locations" action: plant_trees_randomlyC category: "Large Trees";
	// On a press of this button, a tree will be planted at the current red cross' location.
	user_command "Plant a Large Tree at selected location" action: plant_tree_at_locationC category: "Large Trees";

	// On a press of this button, any changes to growth stress multipliers will be committed and canopy size will be recalculated.
	user_command "Commit changes" action: update_values;

	// Define the output of the experiment.
	output {

	// Some useful charts.
		display Charts {
			chart "Canopy proportion in function of time" type: series {
				data "Canopy proportion" value: canopy_percentage color: #green;
				data "Average cooling [°C]" value: average_temperature color: #purple;
			}

		}

		// New 2D display dedicated to map the temperatures.
		display Heatmap type: java2D {
			graphics "Basemap" {
				draw basemap at: {0, 0};
				draw string(cycle + current_year - 2) color: #black font: font('Garamond', 60, #bold) at: {7, 717};
			}

			species temperature_grid aspect: base transparency: 0.5;
		}

		// Define a new 2D display. Main display to witness the growth of the trees in their environment.
		display Environment type: java2D {
		// Do action "get_location" whenever the user left clicks on the map.
			event mouse_down action: get_location;
			graphics "Basemap" {
				draw basemap at: {0, 0};
				draw string(cycle + current_year - 2) color: #black font: font('Garamond', 60, #bold) at: {7, 717};
				draw "Canopy rate" color: #black font: font('Garamond', 40, #bold) at: {182, 22};
				draw string(canopy_percentage) + "%" color: #black font: font('Garamond', 60, #bold) at: {197, 57};
			}

			graphics "LIDAR" {
			//draw lidar2019 color: #black;
			}
			// Declare species tree and its subspecies (birch, oak, etc...).
			species Trees aspect: base;
			species TreesC aspect: base;
			species TreesB aspect: base;
			species TreesA aspect: base;
			// Draw the red cross used to highlight the last location clicked. It updates on each mouse click.
			graphics "Selected Location Highlight" {
				if selected_location != nil {
					draw cross(1.2, 0.3) color: #red border: #black at: selected_location;
				}

			}

		}

		// Numerary monitors to display various key variables during the experiment.
		monitor "Current year" value: string(cycle + current_year - 1) refresh: every(1 #cycle);
		monitor "Total canopy area [m2]" value: total_canopy_area refresh: every(1 #cycle);
		monitor "Canopy proportion [%]" value: canopy_percentage refresh: every(1 #cycle);
		monitor "Average temperature [°C]" value: average_temperature refresh: every(1 #cycle);
		monitor "Amount of Small Trees" value: length(TreesA) refresh: every(1 #cycle);
		monitor "Amount of Medium Trees" value: length(TreesB) refresh: every(1 #cycle);
		monitor "Amount of Large Trees" value: length(TreesC) refresh: every(1 #cycle);
		monitor "Total amount of Trees" value: length(agents of_generic_species Trees) refresh: every(1 #cycle);
		monitor "World area [m2]" value: world_area refresh: every(1 #cycle);
	}

}
